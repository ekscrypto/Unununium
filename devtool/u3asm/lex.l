/*
 * U3ASM
 * $Header: /cvsroot/uuu/devtool/u3asm/lex.l,v 2.4 2003/07/01 11:17:04 daboy Exp $
 * Copyright 2003 by Phil Frost; see file "License".
 */

/** \file lex.cc
 *
 * Lexicographical scanner generated by the program \c flex from \c lex.l. */

%option stack
%option yyclass="Lexer"

	/* anything consisting of these is considered a label */
LABELCHAR	[[:alnum:]_.#@$]
	/* a label not beginning with this invokes a warning because it could be
	 * a directive, number, or other special word that has been mistyped. */
SANELABELCHAR	[[:alpha:]_.@$]

%{

#include "yystype.h"
#include "parse.h"
#include "assembler.h"
#include <string>



%}

%x MULTILINE_COMMENT
%x SQUOTE_STRING	DQUOTE_STRING	STRING_ESC



%%




;[^\n-].*\n		assembler.next_line();
[[:blank:]]+		/* eat whitespace...yum! */
;?\n			assembler.next_line(); // eat newlines like whitespace

r[0-9a-fA-F]{1,2} {
    sscanf( &YYText()[1], "%2X", &yylval.reg );
    return( T_REGISTER );
}

[0-9]+			yylval.immediate=atoll(YYText()); return( T_INTEGER_IMM );
0x[0-9a-fA-F]+		sscanf( YYText()+2, "%llx", &yylval.immediate ); return( T_INTEGER_IMM );
0b[01]+			yylval.immediate=scan_binary( YYText()+2 ); return( T_INTEGER_IMM );
[0-9]+\.[0-9]*		yylval.float_imm=atof(YYText()); return( T_FLOAT_IMM );

#macro		return( T_MACRO );
#orcam		return( T_ORCAM );
#section	return( T_SECTION );
#pushsection	return( T_PUSHSECTION );
#popsection	return( T_POPSECTION );
#error		return( T_ERROR );
#warning	return( T_WARNING );
#remark		return( T_REMARK );
#org		return( T_ORG );
#line		return( T_LINE );
#debug		return( T_DEBUG );
#dumplabels	return( T_DUMPLABELS );
#opcode		return( T_OPCODE );

{SANELABELCHAR}{LABELCHAR}*	return( process_identifier() );
{LABELCHAR}+ {
    assembler.disp_warning() << "label could be a typo" << std::endl;
    return( process_identifier() );
	     }

"<<"			return( T_SHL );
">>"			return( T_SHR );
"&&"			return( T_LAND );
"||"			return( T_LOR );
">="			return( T_GT_EQ );
"<="			return( T_LT_EQ );
"/="			return( T_NE );



";-"			++comment_depth; BEGIN( MULTILINE_COMMENT );
<MULTILINE_COMMENT>{
";-"			++comment_depth;
[^-\n]*
"-"+[^-;\n]*
\n			assembler.next_line();
"-"+";"			if( !--comment_depth ) BEGIN( INITIAL );
}




\" {
    yylval.string = new std::string;
    BEGIN( DQUOTE_STRING );
}

<DQUOTE_STRING>{

[^\n"\\]*\n {
    assembler.next_line();
    yylval.string->append( YYText() );
}

[^\n"\\]* {
    yylval.string->append( YYText() );
}

\\	yy_push_state( STRING_ESC );

\"  {
    BEGIN( INITIAL );

    return T_STRING;
}

}



' {
    yylval.string = new std::string;
    BEGIN( SQUOTE_STRING );
}

<SQUOTE_STRING>{
[^\n'\\]*\n {
    assembler.next_line();
    yylval.string->append( YYText() );
}

[^\n'\\]* {
    yylval.string->append( YYText() );
}

\\	yy_push_state( STRING_ESC );

' {
    BEGIN( INITIAL );

    return( T_STRING );
}
}



<STRING_ESC>{

0 {
    yylval.string->push_back( '\0' );
    yy_pop_state();
}

n {
    yylval.string->push_back( '\n' );
    yy_pop_state();
}

. {
    yylval.string->push_back( *YYText() );
    yy_pop_state();
}

\n {
    assembler.next_line();
    yy_pop_state();
}

}



.			return( *YYText() );



%%



int yywrap()
{
    return 1;
}



int Lexer::process_identifier() {
    if( (yylval.instruction.inst = assembler.instructions.get( YYText() )) ) {
	yylval.instruction.mnemonic = new std::string( YYText() );
	return T_MNEMONIC;
    }
    else {
	yylval.string = new std::string( YYText() );
	return T_STRING;
    }
}



immtype Lexer::scan_binary( const char *text )
{
    immtype result;
    unsigned pos;

    printf( "scanning %.*s in binary\n", yyleng-2, text );

    for( pos = 0, result=0; !( text[pos] != '0' && text[pos] != '1' ); ++pos ) {
	result <<= 1;
	if( text[pos] == '1' ) ++result;
    }

    return result;
}
