#! /usr/bin/perl -w
#
# By EKS - Dave Poirier
# Distributed under the revised BSD License

$API_DIR = "/home/htdocs/api";
$APINDX = "index.html";
$TODAY = `date`;
$API_HEADER =
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">
<HTML>
<HEAD><TITLE>Unununium OSWPI</TITLE></HEAD>
<BODY>
<div align=\"right\"><small>Generated automatically by genapi.pl<BR>$TODAY</small></div>
<H1>Unununium<BR>OS-Wrapper Programming Interface</H1>

<p>
";
$API_FOOTER ="</BODY></HTML>";
$CELL_HEADER =
"<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\">
<!--
Automatically generated by genapi.pl
written by EKS - Dave Poirier
-->
<HTML>
<HEAD><TITLE>Unununium OSWPI</TITLE></HEAD>
<BODY>
<DIV ALIGN=\"RIGHT\"><SMALL>Generated automatically by genapi.pl<BR>$TODAY</SMALL></DIV>
<P>";
$CELL_FOOTER ="<BR><BR><BR><A HREF=\"index.html\">Index</a></BODY></HTML>";

$ERR = 0;

if( $#ARGV < 0 ) {die "This script requires at least one path as parameter\n";}

#
# Creating list of files to process
#
@PATHS = @ARGV;
while( $#PATHS+1 )
{
  $INPATH = pop @PATHS;
  print "adding in files of: $INPATH\n";
  $FINDOUTPUT = `find $INPATH -name "*.asm"`;
  @INFILES = split(/\n/,$FINDOUTPUT);

  # make sure no duplicate file is found
  if( $#FILESTOPROCESS+1 )
  {
    while($#INFILES+1)
    {
      $INFILE = pop @INFILES;
      for $i (0 .. $#FILESTOPROCESS)
      {
	if( $INFILE eq $FILESTOPROCESS[$i] )
	{
	  print "bypassing duplicated file: $INFILE\n";
	  goto infile_ended;
	}
      }
      push @FILESTOPROCESS, $INFILE;
infile_ended:
    }
  }
  else
  {
    @FILESTOPROCESS = @INFILES;
  }
}

#
# Creating API directory
#
$PWD = `pwd`;
chomp $PWD;


if( substr($API_DIR,0,1) eq "~" )
{
  $API_DIR = $ENV{HOME}.substr($API_DIR,1,length($API_DIR)-1);
}
elsif( substr($API_DIR,0,1) ne "/" )
{
  $API_DIR = $PWD."/".$API_DIR;
}

print "generating api in: $API_DIR\n";

exit 1 if( (not &create_dir($API_DIR)) or (not &change_dir($API_DIR)) );

#
# API directory created and now made current directory.
# Create API Index file
#
if( not open(NDX,">",$APINDX) )
{
  print STDERR "Couldn't create api index file: \"$APINDX\": $!\n";
  $ERR++;
  goto enditall;
}

print NDX "$API_HEADER";

goto endcloseapi if( (not &create_dir("cells")) or (not &change_dir("cells")));

goto endcloseapi if( not open(FNDX,">","index.html"));

print FNDX "$API_HEADER<UL>\n";

#
# Generating cells listing
#
#
for $k (0 .. $#FILESTOPROCESS )
{
  $INFILE = $FILESTOPROCESS[$k];
  print "parsing: $INFILE\n";
  if( not open(INF,"<",$INFILE) )
  {
    print STDERR "Couldn't open source file \"$INFILE\": $!\n";
    $ERR++;
    goto endcloseapi;
  }

  @DEPS = @NONE;
  @PROVS = @NONE;
  $CELL_NAME = $INFILE;
  $CELL_NAME =~ s/^.*cell\///;
#  $CELL_LOC = index($INFILE,"cell/");
#  $CELL = substr($INFILE,$CELL_LOC+6,length($INFILE)-$CELL_LOC-6);
#  $CELL_LOC = 0;
#  $OFFS = 0;
#  while( $OFFS+1 )
#  {
#    $CELL_LOC = $OFFS;
#    $OFFS = index($CELL,"/",$CELL_LOC+1);
#  }
#  $CELL = substr($CELL,0,$CELL_LOC);
#  $CELL_NAME = $CELL;
#  $CELL =~ s/\//\./g;
  $CELL = $CELL_NAME.".html";
  $CELL =~ s/\//\./g;
  print STDERR "generating $CELL...\n";
  push @CELLS, $CELL_NAME;
  push @CELLS, $CELL;


  if(not open(CNFO,">",$CELL))
  {
    print STDERR "Couldn't create cell information file \"$API_DIR/cells/$CELL\": $!\n";
    $ERR++;
    goto endclosefndx;
  }
  
  print CNFO "$CELL_HEADER\n<b>cell: $CELL_NAME</b>\n";
  print FNDX "<li><a href=\"$CELL\">$CELL_NAME</a></li>\n";

  $LINE_NUMBER = 0;
  $EXPECT_INFO = 0;
  $INFO_BLOCK = 0;
  $UNCONVERTED_PROV = 0;
  $UNCONVERTED_DEP = 0;
  while(<INF>)
  {
    chomp $_;
    $LINE_NUMBER++;
    if( $INFO_BLOCK )
    {
      $EXPECT_INFO = 0;
      if( ($_ =~ /^\;\</) or not ($_ =~ /^\;\;/))
      {
	$INFO_BLOCK = 0;
      }
      else
      {
	$_ =~ s/^\;\;//;
	push @GPROVS, $_;
      }
    }
    if( $EXPECT_INFO )
    {
      if( $_ =~ /^\;\>/ )
      {
	$INFO_BLOCK = 1;
	$EXPECT_INFO = 0;
      }
    }
    if( $_ =~ /^\s*globalfunc\s+/)
    {
      $INFO_BLOCK = 0;
      $_ =~ s/^\s*globalfunc\s+//;
      $_ =~ s/[,\;].*//;
      if( $_ =~ /\./ )
      {
	push @PROVS, $_;
	push @GPROVS_NDX, $#GPROVS;
	push @GPROVS, $_;
	push @GPROVS, $CELL_NAME;
	$EXPECT_INFO = 1;
      }
      else
      {
	print STDERR "WARNING: unconverted VID detected\n\tfile: $INFILE\n\tline: $LINE_NUMBER\n";
	$UNCONVERTED_PROV = 1;
      }
    }
    elsif( ($_ =~ /^\s*externfunc\s+/))
    {
      $_ =~ s/^\s*externfunc\s+//;
      $_ =~ s/[,\;].*//;
      if( $_ =~ /\./ )
      {
	for $i (0 .. $#DEPS)
	{
	  goto double_deps if( $_ eq $DEPS[$i] );
	}
	push @DEPS, $_;
	push @GDEPS, $_;
	push @GDEPS_CELL, $CELL_NAME;
      }
      else
      {
	print STDERR "WARNING: unconverted VID detected\n\tfile: $INFILE\n\tline: $LINE_NUMBER\n";
	$UNCONVERTED_DEP = 1;
      }
    }
double_deps:
  }

  print CNFO "<P><U>Provides:</U><UL>\n";
  print CNFO "<li>warning: some unconverted VID global detected</li>\n" if $UNCONVERTED_PROV;
  &print_funcs(CNFO, @PROVS);
  print CNFO "</UL><P><U>Requires:</U><UL>\n";
  print CNFO "<li>warning: some unconverted VID extern detected</li>\n" if $UNCONVERTED_DEP;
  &print_funcs(CNFO, @DEPS);
  print CNFO "</UL>$CELL_FOOTER\n";
  close CNFO;
  close INF;
}

print FNDX "</UL><A HREF=\"../index.html\">Back to main</a><P>\n$API_FOOTER";
close FNDX;

print NDX "<li><a href=\"cells/index.html\">by cell</a></li>\n";

chdir $API_DIR;

#
# Generating api/funcs/*
#
#
goto endcloseapi if( (not &create_dir("funcs")) or (not &change_dir("funcs")));

@TMP = @GPROVS_NDX;
while( $#TMP )
{
  $INDX = pop @TMP;
  $FUNC = $GPROVS[$INDX+1];
  $CLASS_LOC = 0;
  $CLASS_OFF = 0;
  while( $CLASS_OFF + 1 )
  {
    $CLASS_LOC = $CLASS_OFF;
    $CLASS_OFF = index($FUNC,".",$CLASS_OFF+1);
  }
  $CLASS = substr($FUNC,0,$CLASS_LOC);

  for $i (0 .. $#FCLASS)
  {
    goto function_class_present if( $CLASS eq $FCLASS[$i]);
  }
  push @FCLASS, $CLASS;
function_class_present:
}

if( not open(FNDX, ">", "index.html"))
{
  print STDERR "Couldn't create \"$API_DIR/funcs/index.html\": $!\n";
  $ERR++;
  goto endcloseapi;
}

print FNDX $API_HEADER;

@FCLASS = sort @FCLASS;
for $k (0 .. $#FCLASS )
{
  $CLASS = $FCLASS[$k];
  $CLASS_FILE = $CLASS.".html";
  @FUNCS = @NOTHING;
  @FUNCS_LONG = @NOTHING;

  print "generating $CLASS_FILE...\n";
  print "\tassociated class is: $CLASS\n";

  if( not open(FNFO, ">", $CLASS_FILE))
  {
    print STDERR "Couldn't create \"$API_DIR/funcs/$CLASS_FILE\": $!\n";
    $ERR++;
    goto endclosefndx
  }
  
  print FNDX "<li><a href=\"$CLASS_FILE\">$CLASS</a></LI><UL>\n";

  print FNFO "$CELL_HEADER<H1>\:\:$CLASS</H1><UL>\n";
  @TMP = @GPROVS_NDX;
  while( $#TMP )
  {
    $INDX = pop @TMP;
    $FUNC = $GPROVS[$INDX+1];
    $CLASS_OFF = 0;
    while( $CLASS_OFF + 1 )
    {
      $CLASS_LOC = $CLASS_OFF;
      $CLASS_OFF = index($FUNC,".",$CLASS_OFF+1);
    }
    if( $CLASS eq substr($FUNC,0,$CLASS_LOC) )
    {
      for $i (0 .. $#FUNCS_LONG)
      {
	goto bypassfunclisting if( $FUNC eq $FUNCS_LONG[$i] );
      }
      push @FUNCS_LONG, $FUNC;
      $FUNC = substr($FUNC,$CLASS_LOC+1,length($FUNC)-$CLASS_LOC-1);
      push @FUNCS, $FUNC;
bypassfunclisting:
    }
  }

  @FUNCS = sort @FUNCS;
  @FUNCS_LONG = sort @FUNCS_LONG;
  for $i (0 .. $#FUNCS)
  {
    $FUNC_LONG = $FUNCS_LONG[$i];
    $FUNC = $FUNCS[$i];
    print FNFO "<LI><A HREF=\"#$FUNC\">$FUNC_LONG</A></LI>\n";
    print FNDX "<LI><A HREF=\"$CLASS_FILE#$FUNC\">$FUNC</A></LI>\n";
  }
  print FNFO "</UL>\n";

  for $i (0 .. $#FUNCS)
  {
    $FUNC = $FUNCS[$i];
    $FUNC_LONG = $FUNCS_LONG[$i];
    @PROVS = @NOTHING;
    print FNFO "<BR><BR><BR><A NAME=\"$FUNC\"><B>$FUNC_LONG</B></A><HR>\n";
    for $j (0 .. $#GPROVS_NDX)
    {
      $INDX = $GPROVS_NDX[$j];
      if( $FUNC_LONG eq $GPROVS[$INDX+1] )
      {
	if( $j eq $#GPROVS_NDX)
	{
	  $INDX_END = $#GPROVS;
	}
	else
	{
	  $INDX_END = $GPROVS_NDX[$j+1] - 1;
	}
	$PROV = $GPROVS[$INDX+2];
	print FNFO "provided by: $PROV<BR>\n";
	if( ($INDX+2) lt $INDX_END) 
	{
	  print FNFO "<BLOCKQUOTE><PRE>";
	  print "value of indx: $INDX\n";
	  $INDX += 2;
	  print "modified value of indx: $INDX\n";
	  while( not ($INDX gt $INDX_END) )
	  {
	    $INFO = $GPROVS[$INDX+1];
	    print FNFO "$INFO\n";
	    $INDX++;
	  }
	  print FNFO "</PRE></BLOCKQUOTE>\n";
	}
      }
    }
    for $j (0 .. $#GDEPS)
    {
      if( $FUNC_LONG eq $GDEPS[$j] )
      {
	$CELL = $GDEPS_CELL[$j];
	print FNFO "required by: $CELL<BR>\n";
      }
    }
  }
  print FNFO "$CELL_FOOTER";
  print FNDX "</UL>\n";
}

print NDX "<li><a href=\"funcs/index.html\">by function</a></li>\n";

endclosefndx:
print FNDX "<A HREF=\"../index.html\">Back to main</a><P>\n$API_FOOTER";
close FNDX;

endcloseapi:
print NDX "$API_FOOTER\n";
close NDX;

enditall:
chdir $PWD;
exit $ERR;



#
# SUB: change_dir
# Changes current working directory to the specified destination and displays
# error message accordingly
#
sub change_dir
{
  local $PWD = `pwd`;
  chomp $PWD;

  if( chdir($_[0]) )
  {
    return 1;
  }

  print STDERR "Couldn't change to directory \"$PWD/$_[0]\n";
  $ERR++;
  return 0;
}


#
# SUB: create_dir
# Creates a specified directory and displays error message accordingly
#
sub create_dir
{
  local $PWD = `pwd`;
  chomp $PWD;

  if( mkdir($_[0]) )
  {
    return 1;
  }
  print "Unable to create directory \"$_[0]\": $!\n";
  $ERR++;
  return 0;
}


#
# SUB: print_funcs
#
#
sub print_funcs
{
  $HANDLE = $_[0];
  @FUNCS = sort @_;
  print $HANDLE "<LI>-none-</LI>\n" if( $#FUNCS eq 0 );
  while( $#FUNCS )
  {
    $_ = pop @FUNCS;
    $URL = $_;
    $URL_LOC = 0;
    $URL_OFF = 0;
    while( $URL_OFF + 1 )
    {
      $URL_LOC = $URL_OFF;
      $URL_OFF = index($URL,".",$URL_OFF+1);
    }
    $URL = "<a href=\"../funcs/".substr($URL,0,$URL_LOC).".html#".substr($URL,$URL_LOC+1,length($URL)-$URL_LOC-1)."\">$URL</a>\n";
    print $HANDLE "<LI>$URL</LI>\n";
  }
}
