\input texinfo @c -*-texinfo-*-
@setfilename UUU_Programmers_Guide
@settitle UUU Programmers' Guide
@setchapternewpage odd

@ifinfo
This documentation describes the Unununium Operating Engine programming
related issues and the various cells currently available to operating
system wrappers.

Copyright @copyright{} 2001 Dave Poirier & Jacques Mony
@end ifinfo

@titlepage
@title Unununium Operating Engine
@subtitle Programmers' Guide
@author Dave Poirier (futur@@mad.scientist.com) 
 Jacques Mony (jmony@@jmony.com)
 Lukas Demetz (luckyluke2000@@web.de)

@page
@vskip 0pt plus 1fill

Copyrights @copyright{} 2001, Dave Poirier & Jacques Mony & Lukas Demetz

Modifications and/or translation of this document are allowed, given the
following conditions:

@itemize
@item the original author is sent an electronic copy to @email{futur@@mad.scientist.com}
@item the modified document is freely available or at minimum charges necessary to cover material reproduction
@item the author be given credit for the original work in the main copyright page
@end itemize

Distibution of this document in non-modified form is unlimited.

@end titlepage

@contents

@unnumbered This guide

This guide was designed so that each chapter can be read individually, in any
order. We tried to make this guide a programmers' reference as much as a
programming tutorial, any comments would be appreciated on that issue.

Any suggestion or correction should be sent to the authors of the document.

Assembly language knowledge is assumed all the way in the book.  Appendices
provide some quick tips on some cpu instructions, but otherwise, an assembly
language reference might prove itself useful to carry on with this guide.

If you don't have any prior knowledge of the Unununium Operating Engine, it
is strongly suggested that you take a look at a document entitled @samp{Unununium
Operating Engine - System Introduction Guide}, which is available for download
from our website at @url{http://uuu.sourceforge.net/}

@page
@chapter Important terminology

 If you ever hope to be able to properly exchange with the other unununium
 programmers, it is imperative that the appropriate terms be used.

@section 4thAxis

 4thAxis is the historical ancestor of Unununium.  The system was not yet using
 a system core, cells were still more like modules, and every header was
 hand-coded rather than generated by a linker.

 The name change was due to some copyright on a name.  Some products using this
 name already exist for embedded controllers and we didn't want to risk a fight
 for the name in the future.

@section Cell

 Basic component of the operating engine on which the operating system
 wrapper is running.  A cell offers functions and most of the time requires some
 other cells.

@section Core

 See @samp{System Core}.

@section DLP

 @samp{Dynamic Linking Point} is used to define a point in a binary that either
 provides a function or global variable, or that uses such function or global
 variable.  Dynamic Linking Point recalculations are relative to the offset
 the binary is loaded, the offset of the associated function or global variable
 and the previous value found at the linking point.

@section DRP

 @samp{Dynamic Recalculation Point} is a term used to define a point in a
 binary that needs to be recalculated at runtime, relative to the offset at
 which the binary was loaded.
 
@section Elf2Core

 First generation linker used to produce first generation system core.  This
 specific linker is not anymore in use.  The sources are still available on our
 cvs repository.  The current linker in use is @samp{U3L}.

@section FBR

 @samp{Full Bloated Recalculation} point.  This term was used in early
 development of Unununium, it is now only an historical curiosity.  The current
 equivalent is @samp{DRP}.

@section GDT

 @samp{Global Descriptor Table} is an Intel Architecture specific data
 structure common in all protected mode operating systems.  This data structure
 is used to create segment descriptor, used to managed access rights to memory
 locations.

@section Handler

 Term used to define a piece of code executing a task on request.  Most of the
 time associated with cpu interrupts, cpu exception or system functions.

@section ICS

 @samp{Inter-Communication System} defines a system of channels, allowing
 processes to send messages in the registers via a client-server mechanism.

 See chapter @samp{Inter-Communication System} for more information.

@section IDT

 @samp{Interrupt Descriptor Table} is an Intel Architecture specific data
 structure common in all protected mode operating systems.  This data structure
 is used to create interrupt descriptor, used to associate hardware interrupt,
 interrupt gate or exception handler to their associated handler.

@section INT

 Short form for @samp{Interrupt}, associated with either software or hardware
 interrupts; this is a term used in most computer architecture, which also
 have in the Intel Architecture an equivalent cpu instruction @samp{int} of
 value 0xCD.
 
@section IRQ

 This term is used in most computer architecture to define an @samp{Interrupt
 ReQuest}, which is directly related to the hardware cpu pin INTQ.  The IRQ
 lines are controlled by a PIC on the x86.

 An IRQ line is what allow a device in a computer to notify the host of a
 message, such as 'operation completed' or 'clock tick'.

@section JIT

 @samp{Just-In-Time} is a technique borrowed from industrial processes. In the
 computer world, it means that runtime modifications are going to be applied.

 We use a technique we call JIT-Linking, which will recalculate calls, jumps
 and absolute references to data or code in the system just prior to execution.

 See chapter @samp{JIT-Linking} for more information.

@section Kernel

 Central controlling unit in an operating systems.  This is the basic component
 on which all operating systems, up to now, were built on. Uuu has no real
 kernel but rather a set of cells that make up the basic system, the system
 core.

@section Linker

 Linkers are used to 'link' together many objects (files) and create one single
 binary.  Commonly known linkers are @samp{ld} and @samp{gnu-ld}. News linkers
 had to be written for Uuu because of Uuu's unique JIT linking process. Two
 generations of Uuu linkers have been created, first a simlpe linker designed
 to only make a runnable system, @samp{Elf2Core}, and later @samp{U3L}, a
 much more flexible, complete linker.

@section OE

 See @samp{Operating Engine}.

@section Operating Engine

 This term is used to represent an environment in which the various tools,
 library and drivers will run.  The operating engine may be seen as a set of
 rules defining how functions can be accessed, how data can be shared, etc.

@section Operating System

 A set of software, libraries and drivers allowing the use of a computer for
 various tasks. An operating system normally includes such things as a text
 editor, file management tools, an email client, etc.

@section OS

 See @samp{Operating System}.

@section PIC

 @samp{Programmable Interrupt Controller} is a chip assigning irq lines to
 interrupt numbers.  It can also assign priority to the irq lines.

@section System Core

 The system core is a special binary, using our own format, that contains an
 operating system wrapper and the various cells required for it to run.
 Optionally the system core may contain a list of DLPs and DRPs.

 The term @samp{System Core} is freely exchangeable with @samp{Core}.

 See chapter @samp{System Core} for more information.

@section U3L

 Second generation linker used to generate the second generation system core.
 This tool is now the most versatile and widely used to generate the system
 core.  The sources are available on the CVS repository.  It replaces the
 previous generation linker,  @samp{Elf2Core}.

 See chapter @samp{U3L - UUU Linker} for more information.

@section V0iD

 The name of an architecture defining a very dynamic model. Mostly, a component
 based model with hot-swapping, no static data, and a single addressing space
 environment.

 See chapter @samp{V0iD Architecture} for more information.

@chapter V0iD Architecture

 @strong{Warning:} These specifications are using the term 'module' while we
 use the term 'cell' in Unununium.  They basically work similarly but see
 chapter @samp{Cell - An organic concept} for more information.

@section Introduction
 Historically, operating systems use a central controlling unit, called kernel,
 and drivers or modules to support that kernel and enhance it.  Some of those
 operating systems allow to dynamically upgrade or reload a module, and some
 even allow to replace the kernel.  They all can be seen as @samp{dynamic}, due
 to the fact that some of their modules may be dynamically reloaded, but
 they all have something in common: they all contain a @samp{static} part.

 Operating system design always made use of some fixed means for application
 to know where they reside.  In some design, they use an interrupt number
 while in others they use a table fixed at a certain memory location.  The
 problem is, they do not allow to be a truly dynamic system, since they
 always have to keep some part of their code or data at a fixed memory
 location, or at a fixed interrupt number.  It becomes even worst when those
 operating systems need to be rebooted in order to upgrade.

 While rebooting a computer may be seen on some system as a @samp{cleanup},
 like MS Windows heavily does, it might not actually be possible or preferable
 to reboot for many reasons.  You may be running a server providing stream
 content to clients, or even controlling some piece of hardware that require
 constant monitoring which cannot be shut down, such as satellites and
 nuclear reactors. This will even affect more day-to-day users working on 
 some database or word processing task, simply wanting to upgrade on of their
 driver, such as mouse or keyboard and requiring to close/reboot/reopen all
 their applications.

 An architecture really dynamic would allow to replace any component without
 rebooting and replace them while they are still "live" or "hot", allowing a
 system to be kept working without loosing the system state, but yet upgrade
 to a newer system or module.  Absolutely no data or code is required to stay
 in memory at a fixed memory location, or at a fixed interrupt number.  Two
 totally different systems could alternate from one to another.

 This architecture is described here, and it is called: VOiD

@section Modularity pushed to outer limits

 There is a possibility of creating a system architecture, where no central
 controlling unit exist, only a community of components, all interacting
 together.  Each of these component being responsible to accomplish a certain
 set of task.

 Typical modular systems have a small central unit called a micro or nano
 kernel.  This micro/nano kernel is responsible for loading/unloading modules.
 While it easily allows replacement of modules themselves, when it comes to
 upgrading the central unit itself, a system restart is most of the time
 required.

 By removing this kernel, even as small as it was, and replacing it by a set
 of small components each dynamically replaceable, the system now becomes
 dynamic and by the same token, more modular, thus easier to develop.

 To accomplish this, it suffice to correctly implement a basic set of function
 in all modules, and allow them to communicate with one another to update
 their pointers to the various modules.

 But even if this system is entirely modular and dynamic once started, we
 still need to have some direction at startup.

@section A typical boot sequence

 On any architecture, a boot sequence is always executed at startup.  This
 boot sequence may vary from one platform to another, but they all include
 a phase of self-testing, loading and running.

 Self-testing is the phase where the system, either software or hardware,
 test the various components of the system to make sure they are serviceable
 and in good condition.

 Loading is the phase where a system is actually loaded into memory to be
 executed later.  The loading sequence might include partition testing,
 floppy or cd-rom seek or even remote system access via a network card.

 Running is the phase where the actual code or sequence loaded in the Loading
 sequence is given control.  At this point, the system may proceed with
 further tests and loading sequences, or may start its "hot" state via a
 user interface or some kind of control system.

@section A VOiD boot sequence

 Note that on some platform, the starting boot sequence may vary.  For
 example, if a VOiD system is located on hard disk, you will probably need
 to first start a BIOS then check for the presence of the hard disk and load
 the code into memory; while on another system which contain VOiD directly
 in a ROM chip, it may be possible to directly give control to that system
 without prior initialization.

 For simplicity, let's imagine that the VOiD system that we want is located
 on the primary active partition of the only hard disk in a typical IBM AT
 compatible computer:

 @itemize
 @item The computer is turned on
 @item The BIOS execute the POST
 @item The BIOS seeks boot devices and load the MBR
 @item The MBR search for an active partition and load the Boot Record
 @item The Boot Record loads the VOiD initializer
 @item The VOiD initializer set a default starting state
 @item The VOiD initializer load and give control to each module for
       initialization and exportation
 @item The VOiD initializer get himself out of memory and start the module
       cooperation
 @item The modules community now controls the system
 @end itemize

 Optionally, this community of modules may also read specific configuration
 files and proceed with further loading and initialization.

@section Module initialization and exportation

 Module exportation is something that some developper consider a waste of
 time, but that is I believe, a more logical and normal action than wasting
 memory for piece of code which won't be used anymore.

 A VOiD module initialization is basically splitted in three general parts:
 
 @itemize
 @item System compatibility test
 @item Module exportation
 @item Module initialization
 @end itemize

 The @samp{system compatibility test} is the period where the currently loaded
 environment will be tested, to see if the module to export can fit in the
 current system.  A module controlling a piece of hardware might prefer
 testing the presence of this hardware before exporting and initializing
 the module.

 @samp{Module exportation} is the actual act of @samp{exporting} the code and
 data representing the part of the module that will stay in memory after the
 initialization sequence is completed.

 While @samp{module initialization} is a sequence to initialize the module to
 a known state, fix various pointers required by the module, link up the
 module in the currently running system, initialize any hardware component
 that may be required, etc.

 Such three parts sequence is the basis to a fully working and upgradable
 system while keeping memory and resource usage at a minimum.  A module
 will not use any memory and will not be installed if it cannot properly
 exist in the system.

 As you may have guessed, each of those three parts may be further
 sub-divided into many little sequences, tasks or tests.  Each module is to
 have its own personalized initialization sequence.

@section Modules coordination

 Coordination requires that modules communicate together.  If modules do not
 exchange information with one another, it becomes increasingly difficult to
 coordinate the efforts of the various components of a system.

 The VOiD architecture accomplish this communication via a communication
 channel in each module.  Please consult the next section in order to have
 more details about inter-module communications.

@section Inter-modules communications

 It is of the utmost importance in a system containing only modules that a
 good communication system exist.  It is not in the scope of this document
 to describe precisely the way to do that, because its implementation
 specific.

 On the other hand, a good communication system would include broadcasting
 functions to announce the location of newly installed modules, modification
 of location of reloaded modules, and start of unavailabitlity of unloaded
 modules.  Such communication function may also include other communication
 such as @samp{end of session} or @samp{reboot request} etc.  It is the role
 of the system implementator to decide of the communication channel to be
 used.

 We none-the-less require of a VOiD architecture, to have its modules
 implement at least this set of communication functions:

 @itemize
 @item Announce newly available module at location X
 @item Announce module end of availability
 @item Announce module relocation to new location X
 @end itemize

 These three functions may be implemented as a set of system messages or
 otherwise.  Again, it is not in the scope of this document to precise the
 specifics of any implementation.

@section Module dynamism

 In order to make a system dynamic, a few things need to be implemented.

 @itemize
 @item It must be possible to load a module after the initial initialization
 @item It must be possible to unload a module
 @end itemize

 These two requirements are the fundamental of dynamic systems.  In VOiD, we
 also specify a few more requirements:

 @itemize
 @item It must be possible to retrieve information about any module loaded
       in the system
 @item It must be possible to entirely change all of the components in the
       system without being forced to leave data at a known location
 @item A module must be "hot" replaceable, meaning that it can be replaced by
       another version of the module while other modules still depends on it.
 @end itemize

 The first of these extra requirement is probably the most fundamental and
 simple one to implement, but yet, it is the one who will lead to the last
 and most complex of those extra requirements.

 The possibility to replace all components assure that a system will be
 entirely replaceable without having to reboot.  Making the system coming
 back to a "clean" state.

 The last of these extra requirement is probably the one characterizing the
 most the VOiD architecture.  It is also probably the one that will cause the
 most headaches to the system implementators, but its the one that will
 garantee that all components can be replaced without shuting down any
 service, making the system reliable and with an uptime of 100%.

@section Hot replacement, howto

 Unfortunately, hot replacement may be accomplished in various ways, and it
 mainly depends on the implementation design.

 For example, it might be possible that to achieve hot replacement, a system
 load the new module, but as long as the other module is required, it redirect
 all service call to the old module.  This other older module will manage
 the various service calls until there's absolutely no more request and will
 transfer atomically the control to the new module; making the change smooth
 and without problems.

 A more chaotic way could be implemented, but it again depends on the
 design but also of the module function.  A system could load the new module
 making all new request managed by this new modules until the old module
 terminates its current service calls.  When the old module will terminate
 its last service call, it will unload itself from memory.

 Or an even more chaotic way could be used.  The new module is loaded,
 initialized and linked, and the old module is automatically unloaded.  While
 this certainly brings lots of concerns in a multi-process/multi-threading
 environment, this certainly is possible to do in a single task system.
 
 What is important to remember, is that a certain communication and
 synchronization between the old and the new module need to be maintained or
 established.  It is then very important that system designers include the
 necessary mechanism to achieve such goal.

@section User Interface, only a front-end

 The user interface in too many system is built-in the os design.  While
 sometime it makes the initial os development simpler, on the long term, it
 becomes a handicap of huge importance.

 The user interface in any operating system represent most of the experience
 that the user will have.  The look-n-feel of a user interface may be changed
 without necessarily affecting the underlying design of the entire system.

 VOiD requires that the user interface be somewhat modularized, which mean
 that it would easily be possible for a user to switch from one user interface
 to another.

 To accomplish this, the user interface could be "modularized", but also, it
 must include functions to allow the replacement of this user interface
 module.  It could be as simple as providing a command line 'loadui ' or
 offering a menu with the current user interface available to the user. More
 important, one of the major benefit of separating the user interface from the
 underlying structures, is that it simplifies the distribution of the os for
 various embedded devices. A car mp3player would certainly not work with a
 command line prompt, but most likely with a simple panel with a dozen of
 buttons, while a PDA will probably use some kind of pen to trace line and
 draw text, but also click on the various buttons of the GUI. To be VOiD
 compliant, you do not have to offer more than one user interface, but you
 need to have the functionalities in place to easily offer various user
 interfaces and an easy way to switch between them.

@chapter Cell Programming
@section Structure of a cell
 A cell follows a particular structure. It has sections. Of course, the main
 section is .text, but other sections are specially reserved by the U3L Linker
 to allow the Unununium Core to operate correctly.

 The sections are described in the U3L Linker chapter.

@section How to make a cell
 To make a cell, you need to put the required sections in your assembly file,
 as well as having a makefile ready for it. You can adapt an existing cell
 makefile to your cell.

 Once done, you need to know how to provide services and use external services
 (from other cells).

@subsection Providing Services

 To provide a service, you do this:

 globalfunc __function_name, class, 8888, 9999

 where globalfunc is a macro (it stays like this), __function_name is the 
 function name you "declare" and class is the class of the function (because 
 some function names such as "__read" might be used in different contexts, 
 such as file I/O, string handling, network I/O, ...). Finally, you have 
 8888 and 9999, which are the function ID (FID) and the class ID (CID). 
 These numbers must be reserved.

 However, if you commit your cell to the main CVS repository, an ID scanner 
 will tell people which IDs are already being used.

 Then, you make your function and end it with

 clc
 retn

 clc means that there was no error. retn returns to the caller.

@subsection Calling Services

 To call an external service, you simply do this:

 externfunc __function_name, class

 Note that you don't need the IDs. Also note that the cell containing these 
 called services MUST be present in the same Core... which means it must be
 in the distribution makefile.

@chapter Application Programming

  This chapter presents how to make applications for Unununium Operating
  Engine.

  While there aren't much differences between an Uuu OE application and
  another OS application, calling external functions in an application is
  done like in a cell. Also, there are some things to take care about and
  also some sections in applications too.

@chapter Dynamic Structures

  Dynamic Structures allow better performances. That is why we use them. Dynamic
  Structures are structures that are dynamically updatable. A dynamically
  updated call will allow the call to jump directly to a given function,
  instead of calling a dispatching function. It allows to save steps in a call
  process.

  Another thing that can be dynamically updated is the pointer to some data.
  For example, a database gets replaced by another. The new one is loaded
  before the old one is removed from memory. So, they won't be at the same
  position in memory. What we need to do at this moment is change the pointers
  that refer to this database and make them point to our new database.

  The database example might not be the best one, but it describes dynamic
  update of datas.

  The main use of dynamic structures is of course for function calls. Some
  functions can be replaced by new versions on the fly, without any reboot,
  if we know where are the pointers to this updated piece of code. This
  is why we are using a JIT architecture, which allows to keep track of
  the required functions by each loaded executable code.

@chapter Inter-Communication System
@section What is ICS?
 ICS is a system that allows programs and functions to communicate with each
 other. It works like a chat. You have ICS channels. For example, you create
 an ICS channel for IP packets input. The network cell will own this channel
 and will output the packets it receives to it. A mail program could then
 connect itself to this channel and look for POP3 packets. The packets will 
 go into all registered programs up to a function that wants it. This allows
 a structured and organized communication. You can find uses for ICS by 
 yourself.

 In the VOiD documentation chapter, the inter-modules communication uses
 ICS. This is its main use.

@section How to use ICS?
 To use ICS, you simply need to request channels and handlers to receiver
 functions.

@chapter U3L - UUU Linker
@section Introduction

 The @samp{UUU Linker}, or more commonly called @samp{U3L}, is currently the
 widely accepted default linker used to build system core for any UUU based
 distribution.

 This linker is the successor of @samp{Elf2Core}, and play a similar purpose,
 if not the same but in a more advanced and specialized way.  The main purpose
 of both linkers is to link multiple ELF objects together in what is called a
 system core. (for more information on system core, please consult the
 @samp{System Core} chapter)

 For sake of simplicity, here are the various steps performed by the linker:
 @itemize
 @item parse command line for object filenames and build a list of them
 @item open each object, making sure it is a valid elf object, and acquiring
 some basic information, such as: sections, string table, symbol table.
 @item create an ordered section list, like it shall be included in the final
 core
 @item calculate the offsets of each section from the start of the system core
 @item update the various symbol table and build a list of global values
 @item generate a list of all global functions identified
 @item generate a core, recalculating each section as they are processed
 @end itemize

@section Linker sequence reviewed

 Each elf object represent at the start a @samp{cell} or an @samp{operating
 system wrapper}.   The linker takes the various elf object in the order they
 are presented on the command line, and will prepare them for inclusion in the
 final system core.  Special sections are marked, others are simply listed for
 future sorting and reference.

 Upon completion of the basic survey of the elf objects, sorting of the various
 sections found in each one of them is achieved.  The specially marked sections
 are included/duplicated where they belong in the final system core and we
 proceed with first offset computations, which consist of finding the offset
 from the start of the system core to the start of the section to be included.

 Associated with most of the sections is a symbol table, containing some
 global and external symbols.  The various global symbols value are computed
 taking into account the offset of the section with which they are associated.
 Each global symbol is also added into a master list, that will also be used
 to fill in the external symbols required in the other sections.

 A second phase closely related is the generation of all the global functions
 identified.  A global function is differentiated from other globals only by
 its name (see section @samp{Global function identification}).

 The last task to complete is to use all the symbols, sections and objects to
 generate the system core.  Each section will be read in the order they were
 sorted, and will be written with applied recalculations.


@section Special ELF sections

 Even if the elf standard define a few sections as reserved, we have felt the
 need to define our own set of specialized section.  Those sections are defined
 here.

@subsection .c_init

  This section represent the initialization section of a cell.  The code and
  data located in this section will be loaded in memory everytime the cell is
  imported, and will be given control so as to be able to initialize the cell
  or devices related to it.  Once this code will return control, all the data
  and code located in this section will be removed and 

@subsection .c_onetime_init

  This very special section is given control only once after a cell is first
  launched in a distribution.  It is given control before any other section,
  and after the completion of it, it is removed from memory and the remaining
  of the cell is seen saved back on disk (if available).

  As the name implied, if the cell was successfully saved on disk, this section
  will never again be loaded into memory and never again be given control. It
  could then be use to check once if the required hardware is present, and if
  so 'prepare' the cell with the proper parameter to access it.  Every time
  the cell will then be loaded, it won't need to 'probe' for the hardware but
  will be able to initialize it directly.

  There are many other uses possible for this section, but it must be used
  carefully, and be accompanied by good distro support to allow the 'initial'
  cell with this section to be reloaded on request, such as when you change
  your hardware.

@subsection .c_osw_pre_init

  Operating System Wrapper entrance section.  In the system core, it is the
  first section to be given control.  It is where the operating system wrapper
  can prepare itself for the initialization of the various cells


@chapter Unununium's functions
@section Inputs
  Sure, the first thing you'll want to know is about the Input functions. For this, we
  have the cells in the src/cells/io branch.
  
@subsection Keyboard
  Cell to use: io/kbd_at/osmium
  
  You get keyboard input by using one of the @samp( set_client) functions.
  Every time a key gets pressed or released, the given function of your code will be called.
  
@subsection Mouse
  Cell to use: either io/mouse/ps2 or io/mouse/microsoft
  
  Analog to the Keyboard, you get the mouse informations by calling the @samp(set_client) function.
  You'll then be informed about mouse position and button pressed everytime the infos change.
  
@section Outputs
  Hell, this is gonna be a really huge section. We actually have many different ways to put something on screen,
  we also have sound support. Anyway, gotta see the possibilities.
  
@subsection Text to screen
  Cell to use: debug/diable or video/display_manager/silicium (Video and text mode)
  
  Here we come to a pretty interesting part. If you want quick output to screen, use diable's @samp(showstr, debug) or
  @samp(showstr, debug_ack). Otherwise, the display manager will give you WAY more functions, 
  like multiple consoles. The third possibility is to write on your own a
  screen routine or to use a non-UUU-included one (like a shell's).
  
@subsection 3D output
  Cell to use: 3d/hydro3d
  
  Yes, it's true. We already have a 3d engine included. Even a VRML-model converter is in @samp(src/tools/vrml2h2o).
  To use it, however, is a pretty complicated way. Take a look at the source, you'll see ;)
  
@subsection Sound
  Cell to use: sound/fantasia
  
  This cell provides some simple functions for SB-compatible cards.
  You'll mainly use the @samp(__play_sound.c_single_shot) function.
  
@subsection Graphic mode
  Cell to use: video/display_manager/silicium and video/VGA
  
  Hell, this is for now a pretty poor angle in UUU. 'Only' VGA is implemented for now.
  You'll mainly use the @samp(set_resolution) function and write (for now) directly
  into video memory.
  
@subsection Debugging
  Cell to use: pretty everything in debug/
  
  Yes, yes. Even in UUU you'll have to debug from time to time your code.
  Anyway, take a look in the sources there. Mainly, you'll use @samp( yttrium)'s
  functions. It's the @samp(system log's) cell. That means, everything sent to this
  cell ends in a log, the system log. During startup, youll see it ;)
  
  Sample:
  	lea	edx, [my_string]
  	externfunc	string_out, system_log
  	; end
  	my_string: db "Hello, world",0
  
  NOTE: the ending '0' singnals a new line, line ends. An ending '1' signals
  	to NOT terminate the line. That is useful to print something like:
  
  Sample:
  	lea	edx, [my_string]
  	externfunc	string_out, system_log
  	lea	edx, [my_ender]
  	externfunc	string_out, system_log
  	; end
  	my_string: db "Hello, world",1
  	my_ender: db "!!!!!",0
  	; this will result in: 'Hello world!!!!!' <new line>
  	
  It is also possible to give out float, decimal, binary and hex values.
  Everytime the values get passed through EDX.
  
  	mov	edx, 0124
  	externfunc	decimal_out, system_log
  	externfunc	hex_out, system_log
  	externfunc	float_out, system_log
  	externfunc	binary_out, system_log
  	
  Then, there are also functions to dump registers and fpu registers
  to the system log:
  	
  	; <no arguments>
  	externfunc	dump_registers, system_log
  	externfunc	dump_fpu_registers, system_log
  	

  Not to forget, there is also @samp(EHEX), a HEX editor ;)
  Yust call it like:
  	
  	mov	esi, 100h	; memory location to start editing
  	externfunc	edit_memory_location, debug
  	
@subsection RealMode / BIOS
  cell to use: realmode/calcium
  
  Gah... YOu really wish to use BIOS in such a powerful OE? heh, yeah.
  It's powerful, but BIOS could give you a great hand. Here how to use it:
  
  
  	< all regs rest = param >
  	push	eax
  	push	word	10h	; RM ES value
  	push	word	11h	; RM DS value
  	push	byte	00000000h ; Slave PIC mask (bit 7 = irq 7, bit 0 = irq 0)
  	push	byte	00000000h ; Master PIC mask (bit 7 = irq 15, bit 0 = irq 8)
  	push	byte	00h
  	push	byte	13h	; Interrupt number
  	
  	externfunc	__procedure_call, realmode
  	
  	pop dword eax
  	pop eax
  	pop eax
  	
@subsection Interrupts in Protected Mode
  Cell to use: idt_irq/potassium
  
  You need to hook an interrupt? Well, then you're right with the @samp(potassium)
  cell. Here the main functions:
  	
  	; hook it!
  	mov	al, 16	; IRQ number
  	lea	esi, [myHandler]
  	externfunc	hook_irq, noclass
  	
  	; and then unhook it ;P
  	
  	mov	al, 16	; IRQ number
  	lea	esi, [myHandler]
  	externfunc	unhook_irq, noclass

  You see, its pretty cool and simple :)
  
@subsection Memory
  Cell to use: memory_manager/oxygen
  
  Thats most probabilly the 'heart' of the OE and also of your code.
  
  NOTE: NEVER use the memory like you want it!!!
  
  Sample:
  	xor	edx, edx	; no special flags
  	mov	ecx, 1024	; get 1 kb (= 1024 bytes)
  	externfunc	malloc, noclass
  	
  NOTE: There are also versions of malloc for memory ranges under 16MB and
  	under 1 MB RAM, for special purposes.
  	
@subsection Multithreading
  Cell to use: thread/strontium
  
  True! We have already preemptive multithreading! We use for now a simple 
  round-robin algorithm. I wont for now explain the full possibilities that are there, but only the most simple ones:
  
  	; Create a thread
  	< load all regs initial values >
  	push	dword 00h	; no special options
  	push	dword 00h	; New process (otherwise process id of parent)
  	push	dword 01h	; priority
  	push	dword offset [mynewThreadFunction]
  	externfunc	create_thread, noclass
  	
  	; EAX = Thread ID returned
  	
  	;; Now, get the thread to sleep
  	; in: EAX = Thread ID
  	externfunc	sleep_thread, noclass
  	
  	;; Wake it up
  	; in: EAX = Thread ID
  	externfunc	wake_thread, noclass
  	
  	;; Kill it!! >:) 
  	; in: EAX = Thread ID
  	externfunc	kill_thread, noclass
  	
  	
  NOTE: The sleep, wake and kill functions are also available as @samp(self) versions.
  	(like: kill_thread, self). They can only be called from the thread himself.
  	
  	
  Continuing with this superb cell, there are nice functions: semaphores and critical sections.
  Anyway, check the source to see the exact working of it.
  
  Also a nice is the @samp(timed_delay, low_resolution) function. It allows you
  (or better, your app) to wait for a given time before continuing execution.
  Here an example:
  
  	mov	ecx, 10	; number of 15.085us ticks to wait
  	externfunc	timed_delay, low_resolution

@subsection FS
  Cell to use: storage/ozone
  
  Heh, we have probabily the most sophisticated FS and storage subsystem on the world. Take the power 
  and try by yourself!
  
  	;open a file
  	filename: db "/usr/luke/madman.mp3",0
  	lea 	esi, [filename]
  	externfunc	open, file
  	;; EBX = FileHandle
  	
  	;Now, we have a handle
  	
  	
  [More to come]

@chapter Book Improvements
@section Things to do
  A lot of chapters and sections need to be complete/added. The todo list can't
  be really precised at the moment... there is so much to do. However, the
  application programming needs some work.

@section Tools used
  The book is written using text editors (such as VIM) in pure texinfo
  formatting.
  
@section Thanks to
  Thanks to Dave Poirere aka EKS for his idea and his big efforts for this OE. 
  Thanks to Phil Frost, Richard Fillion and Lukas Demetz for the many hours invested in coding.
  Thanks to Michael Römer and Jeroen van Wissen for the nice website.
  Thanks also to our active members, for 'em efforts to bring us ahead:
  Cesar Yanez Fernandez, Chris Farber, Danny Doris, Gabriel Klein, Jacques Mony, 
  Mark McKenna, Niklas Klügel, Sean Stanek, Simon Putz, Stanislav Karchebny, Andrea Fois.
  
  Thanks to all you! Thanks for trying out our work!
  
@section About the authors
  The authors of this document are all heavy-main UUU coders. It isn't strange if the doc
  here is really basilar, because the OE changes within hours.
  However, Lukas Demetz got now enough time to take care of this doc. If you have any questions about programming
  for UUU or something related to this doc or UUU, don't hesitate to contact me:
  @email(luckyluke2000@web.de)
  

  
  
@bye

